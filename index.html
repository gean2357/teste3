<!DOCTYPE html>
<html>
<head>
  <title>Dennis Vision - Full Body Tracking</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
    canvas { position: absolute; top: 0; left: 0; }
    video { transform: scaleX(-1); width: 100vw; height: 100vh; object-fit: cover; display: none; }
    #ui { 
      position: absolute; top: 20px; left: 20px; z-index: 10;
      color: white; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px; border: 1px solid #00ffff;
    }
  </style>
</head>
<body>
  <div id="ui">
    <b>Dennis Vision: Modo Corpo Total</b><br>
    üîµ Rosto | üü¢ M√£os | üü£ Corpo (Pose)<br>
    üëâ Pin√ßa para desenhar | ‚å®Ô∏è Espa√ßo: Limpa
  </div>
  <video id="webcam" autoplay playsinline></video>
  <canvas id="output_canvas"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <script>
    const videoElement = document.getElementById('webcam');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    
    let points = []; 

    function onResults(handResults, faceResults, poseResults) {
      canvasElement.width = window.innerWidth;
      canvasElement.height = window.innerHeight;

      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      
      // Espelhamento
      canvasCtx.translate(canvasElement.width, 0);
      canvasCtx.scale(-1, 1);
      
      // 1. DESENHA O V√çDEO NO FUNDO
      if (handResults.image) {
        canvasCtx.drawImage(handResults.image, 0, 0, canvasElement.width, canvasElement.height);
      }

      // 2. DESENHA O CORPO TODO (POSE) - Cor Roxa
      if (poseResults && poseResults.poseLandmarks) {
        drawConnectors(canvasCtx, poseResults.poseLandmarks, POSE_CONNECTIONS,
                      {color: '#AFEEEE', lineWidth: 4});
        drawLandmarks(canvasCtx, poseResults.poseLandmarks,
                      {color: '#9370DB', lineWidth: 2, radius: 4});
      }

      // 3. DESENHA O ROSTO (FACE MESH) - Cor Branca/Cinza
      if (faceResults && faceResults.multiFaceLandmarks) {
        for (const landmarks of faceResults.multiFaceLandmarks) {
          drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, {color: '#C0C0C040', lineWidth: 1});
          drawConnectors(canvasCtx, landmarks, FACEMESH_FACE_OVAL, {color: '#FFFFFF', lineWidth: 2});
        }
      }

      // 4. DESENHA A M√ÉO E L√ìGICA DE PIN√áA - Cor Verde
      if (handResults.multiHandLandmarks) {
        for (const landmarks of handResults.multiHandLandmarks) {
          drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});

          const thumbTip = landmarks[4];
          const indexTip = landmarks[8];
          const distance = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);

          if (distance < 0.05) {
            points.push({x: indexTip.x * canvasElement.width, y: indexTip.y * canvasElement.height});
          } else if (points.length > 0 && points[points.length-1] !== null) {
            points.push(null);
          }
        }
      }

      // 5. DESENHA O RASTRO DO DESENHO - Cor Ciano
      canvasCtx.beginPath();
      canvasCtx.lineWidth = 6;
      canvasCtx.strokeStyle = "#00ffff";
      canvasCtx.shadowBlur = 10;
      canvasCtx.shadowColor = "#00ffff";
      for (let i = 1; i < points.length; i++) {
        if (points[i] && points[i-1]) {
          canvasCtx.moveTo(points[i-1].x, points[i-1].y);
          canvasCtx.lineTo(points[i].x, points[i].y);
        }
      }
      canvasCtx.stroke();
      canvasCtx.restore();
    }

    // Configura√ß√£o dos Modelos
    const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
    faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5 });

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.5 });

    const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
    pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5 });

    // Sincroniza√ß√£o Tripla
    let lastHand = {}, lastFace = {};
    hands.onResults(h => lastHand = h);
    faceMesh.onResults(f => lastFace = f);
    pose.onResults(p => onResults(lastHand, lastFace, p));

    const camera = new Camera(videoElement, {
      onFrame: async () => {
        await hands.send({image: videoElement});
        await faceMesh.send({image: videoElement});
        await pose.send({image: videoElement});
      },
      width: 1280, height: 720
    });
    camera.start();

    window.addEventListener('keydown', (e) => { if(e.code === 'Space') points = []; });
  </script>
</body>
</html>
